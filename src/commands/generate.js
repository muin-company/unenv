const fs = require('fs');
const path = require('path');
const chalk = require('chalk');
const ora = require('ora');
const { scanDirectory, CATEGORIES } = require('../scanner');

/**
 * Generate helpful comment for a variable based on its category and name
 */
function generateComment(varName, category) {
  const comments = {
    'Database': 'Database connection string',
    'API & Services': 'API endpoint or service URL',
    'Authentication': 'Authentication credential - keep secret!',
    'Cloud & Infrastructure': 'Cloud service configuration',
    'Application': 'Application configuration',
    'Email & Communication': 'Email/messaging service configuration',
    'Payment': 'Payment provider configuration - keep secret!',
  };
  
  let comment = comments[category] || 'Environment variable';
  
  // Add specific hints based on name
  if (varName.includes('URL') || varName.includes('URI')) {
    comment += ' (URL format)';
  } else if (varName.includes('PORT')) {
    comment += ' (number)';
  } else if (varName.includes('KEY') || varName.includes('SECRET') || varName.includes('PASSWORD')) {
    comment += ' - DO NOT COMMIT!';
  } else if (varName === 'NODE_ENV') {
    comment = 'Environment: development | production | test';
  }
  
  return comment;
}

/**
 * Generate .env.example content
 */
function generateEnvExample(variables, categorize = true) {
  let content = '# Generated by unenv\n';
  content += `# ${new Date().toISOString()}\n`;
  content += '#\n';
  content += '# Copy this file to .env and fill in your values\n';
  content += '# DO NOT commit .env to version control!\n\n';
  
  if (categorize) {
    // Group by category
    const grouped = {};
    
    variables.forEach(v => {
      if (!grouped[v.category]) {
        grouped[v.category] = [];
      }
      grouped[v.category].push(v);
    });
    
    // Sort categories (put important ones first)
    const priorityOrder = [
      'Database',
      'Authentication',
      'API & Services',
      'Cloud & Infrastructure',
      'Application',
      'Email & Communication',
      'Payment',
      'Other',
    ];
    
    const sortedCategories = Object.keys(grouped).sort((a, b) => {
      const aIndex = priorityOrder.indexOf(a);
      const bIndex = priorityOrder.indexOf(b);
      if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
      if (aIndex === -1) return 1;
      if (bIndex === -1) return -1;
      return aIndex - bIndex;
    });
    
    sortedCategories.forEach(category => {
      content += `# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      content += `# ${category}\n`;
      content += `# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n`;
      
      grouped[category].sort((a, b) => a.name.localeCompare(b.name)).forEach(v => {
        const comment = generateComment(v.name, v.category);
        content += `# ${comment}\n`;
        
        // Add usage hint
        if (v.locations.length === 1) {
          content += `# Used in: ${v.locations[0].file}\n`;
        } else {
          content += `# Used in: ${v.locations[0].file} +${v.locations.length - 1} more\n`;
        }
        
        content += `${v.name}=\n\n`;
      });
    });
  } else {
    // Alphabetical list
    variables.sort((a, b) => a.name.localeCompare(b.name)).forEach(v => {
      const comment = generateComment(v.name, v.category);
      content += `# ${comment}\n`;
      content += `# Used in: ${v.locations[0].file}\n`;
      content += `${v.name}=\n\n`;
    });
  }
  
  return content;
}

/**
 * Check .gitignore for .env safety
 */
function checkGitignore(dir) {
  const gitignorePath = path.join(dir, '.gitignore');
  
  if (!fs.existsSync(gitignorePath)) {
    return {
      exists: false,
      hasEnv: false,
    };
  }
  
  const content = fs.readFileSync(gitignorePath, 'utf8');
  const hasEnv = content.split('\n').some(line => {
    const trimmed = line.trim();
    return trimmed === '.env' || trimmed === '.env.local' || trimmed.startsWith('.env');
  });
  
  return {
    exists: true,
    hasEnv,
  };
}

async function generate(options) {
  const dir = path.resolve(options.dir);
  const outputPath = path.join(dir, options.output);
  const spinner = ora('Scanning codebase...').start();
  
  try {
    const ignorePatterns = options.ignore ? options.ignore.split(',') : [];
    const result = await scanDirectory(dir, ignorePatterns);
    
    spinner.succeed(`Analyzed ${chalk.bold(result.totalFiles)} files`);
    
    if (result.variables.length === 0) {
      console.log(chalk.yellow('âš  No environment variables found - nothing to generate'));
      return;
    }
    
    // Generate content
    const content = generateEnvExample(result.variables, options.categorize);
    fs.writeFileSync(outputPath, content, 'utf8');
    
    console.log(chalk.green(`âœ“ Created ${chalk.bold(path.relative(dir, outputPath))} with ${chalk.bold(result.variables.length)} variables\n`));
    
    // Show preview
    console.log(chalk.dim('Preview (first 10 lines):'));
    console.log(chalk.dim('â”€'.repeat(60)));
    const lines = content.split('\n').slice(0, 10);
    lines.forEach(line => console.log(chalk.dim(line)));
    if (content.split('\n').length > 10) {
      console.log(chalk.dim('...'));
    }
    console.log(chalk.dim('â”€'.repeat(60)));
    console.log('');
    
    // Check .gitignore
    const gitignore = checkGitignore(dir);
    
    if (!gitignore.exists) {
      console.log(chalk.yellow('âš  No .gitignore found'));
      console.log(chalk.yellow('  Create one and add .env to protect secrets!\n'));
    } else if (!gitignore.hasEnv) {
      console.log(chalk.red('âš  .env is not in .gitignore!'));
      console.log(chalk.red('  Add it now to prevent committing secrets:\n'));
      console.log(chalk.cyan('  echo ".env" >> .gitignore'));
      console.log(chalk.cyan('  echo ".env.local" >> .gitignore\n'));
    } else {
      console.log(chalk.green('âœ“ .env is safely ignored by git\n'));
    }
    
    // Next steps
    console.log(chalk.cyan('ðŸ’¡ Next steps:'));
    console.log(chalk.cyan(`  1. Copy ${options.output} to .env`));
    console.log(chalk.cyan('  2. Fill in your actual values'));
    console.log(chalk.cyan(`  3. Run ${chalk.bold('unenv check')} to validate\n`));
    
  } catch (error) {
    spinner.fail('Generation failed');
    console.error(chalk.red(error.message));
    process.exit(1);
  }
}

module.exports = { generate };
